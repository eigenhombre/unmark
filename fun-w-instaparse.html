<head><link href="tufte-css/tufte.css" rel="stylesheet" /></head><body><div><h1>Fun with Instaparse</h1><p><span>One of my favorite talks from this month's excellent <a href="http://clojure-conj.org/">Clojure/conj</a> was <a href="http://gigasquid.github.io/">Carin Meier</a>'s presentation, which combined storytelling, live coding, philosophy,
     the history of computing, and flying robotic drones. She used the
     relatively new <a href="https://github.com/Engelberg/instaparse">Instaparse library</a> to <a href="http://gigasquidsoftware.com/wordpress/?p=689">create her
     own language</a> to explore something called &ldquo;Speech Acts&rdquo; (which I won't
     go into here, but do catch the video of her talk when it goes up).</span></p><p><span>My university work was in physics (and art) rather than CS, but I
     have long been interested in the implementation of programming languages,
     even going so far as to write a simple parser for Lisp-style math
     expressions in Pascal many years ago. Last year I had the opportunity to
     take the first <a href="http://dabeaz.blogspot.com/2012/01/compiler-experiment-begins.html">&ldquo;write a compiler in Python&rdquo; class</a> offered by <a href="http://dabeaz.com">David Beazley</a> here in Chicago, in which we implemented a subset of the Go
      language. His <a href="http://www.dabeaz.com/ply/index.html">PLY</a> library is a great way
     to get started with implementing language parsers in Python, and the
     relative ease of doing so, compared with classic C implementations
     described in the infamous <a href="http://www.amazon.comCompilers-Principles-Techniques-Alfred-Aho/dp/0201100886">Dragon Book</a>, inspired me to do some further <a href="https://github.com/eigenhombre/PyClojure">experimentation of my own</a>.</span></p><p>With this background, and inspired by Carin's talk, I have been waiting
     for an opportunity to try out Instaparse, which is getting great press in
     the Clojure world. Instaparse takes a grammar as input (in the form of a
     string), and gives you a parser in the language specified by that
     grammar. It will also let you specify rules for transforming the
     resulting tree into something your Clojure program can use more directly
     (for example, by converting data types or removing unneeded elements from
     the parse tree).</p><p><span>When the need arose this weekend to read in Python configuration
     files into a Clojure program, I decided the time was ripe. I also wanted
     to document the journey using some form of <a href="http://en.wikipedia.org/wiki/Literate_programming">literate programming</a>. A library called <a href="https://github.com/gdeer81/marginalia">Marginalia</a> (Michael Fogus <em>et. al.</em>) made this pretty easy.</span></p><p><span>The results are <a href="http://eigenhombre.com/semi-literate-programming/parsepy.html">here</a>, as well as on <a href="https://github.com/eigenhombre/parsepy">GitHub</a>.</span></p><p>My impressions, after doing this project in just a few hours, are that
     (1) literate programming is great fun; and (2) Instaparse sets a new
     standard for power and expressiveness when converting structured text
     into abstract syntax trees. If you have a DSL or some other text-based,
     formal language you want to parse, and you are either literate in Clojure
     or interested in becoming so, Instaparse would be a great tool to check
     out.</p></div></body><div><p><a href="about.html">about</a>|<a href="content.html">all posts</a></p><p>&copy; 2015 <a href="about.html">John Jacobsen</a>. Created with <a href="https://github.com/eigenhombre/unmark">unmark</a>.  CSS by <a href="https://edwardtufte.github.io/tufte-css/">Tufte-CSS</a>.</p></div>